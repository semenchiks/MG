<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ожидаем ответы</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="data:,">
  <style>
    html, body { overflow: auto; }
    .page { min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 24px; }
    .panel { width: 100%; max-width: 1120px; background: #ffffff; border: none; border-radius: 20px; box-shadow: 0 12px 32px rgba(0,0,0,0.08); padding: 42px; text-align: center; }
    .title { font-weight: 900; font-size: 44px; margin-bottom: 22px; }
    .loader { display: inline-flex; gap: 10px; margin: 14px 0 28px; }
    .dot { width: 14px; height: 14px; border-radius: 50%; background: var(--yellow-primary); animation: pulse 1.2s infinite ease-in-out; }
    .dot:nth-child(2) { animation-delay: .15s; }
    .dot:nth-child(3) { animation-delay: .3s; }
    @keyframes pulse { 0%, 80%, 100% { transform: scale(0.6); opacity: .5; } 40% { transform: scale(1); opacity: 1; } }
    .metrics { display: grid; gap: 14px; margin-top: 12px; }
    .metric { font-size: 26px; font-weight: 900; }
    .metric span { font-weight: 800; }
    /* Плавное скрытие загрузки и метрик */
    .loader, .metrics { transition: opacity .6s ease, transform .6s ease; }
    .fade-out { opacity: 0 !important; transform: translateY(8px); pointer-events: none; }
    /* Облако тегов */
    .cloud { display: none; margin-top: 36px; min-height: 560px; position: relative; overflow: hidden; opacity: 0; transition: opacity .8s ease .15s; contain: layout paint; }
    .cloud.show { display: block; }
    .cloud.visible { opacity: 1; }
    .tag { position: absolute; padding: 0; background: transparent; color: var(--tag-color, #222); border: 0; font-weight: 900; white-space: nowrap; line-height: 1; will-change: transform, opacity, filter; border-radius: 0; box-shadow: none; }
    /* Плавное поэтапное появление + небольшое парение */
    .cloud-enter { animation: cloudIntro .9s cubic-bezier(.22,.61,.36,1) both; animation-delay: var(--delay, 0s); }
    @keyframes cloudIntro { 0% { opacity: 0; transform: translateY(12px) scale(.9) rotate(var(--rot, 0deg)); filter: blur(6px); } 60% { opacity: 1; transform: translateY(-3px) scale(1.03) rotate(calc(var(--rot, 0deg) * -0.3)); filter: blur(0); } 100% { opacity: 1; transform: translateY(0) scale(1) rotate(0); } }
    .float { animation: floatY 6s ease-in-out infinite; animation-delay: var(--floatDelay, 1s); }
    @keyframes floatY { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
  </style>
</head>
<body>
  <div class="page">
    <div class="panel" role="region" aria-label="Ожидание ответов">
      <div class="title">Ожидаем ответов</div>
      <div class="loader" aria-hidden="true">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div class="metrics">
        <div class="metric">Отвечающих пользователей: <span id="responding-count">0</span></div>
        <div class="metric">Пользователей, давших ответ: <span id="answered-count">0</span></div>
      </div>
      <div id="tags-cloud" class="cloud" aria-live="polite"></div>
    </div>
  </div>

  <script>
    // Подключаем Socket.IO и слушаем статистику
    (function(){
      const script = document.createElement('script');
      script.src = 'https://cdn.socket.io/4.5.0/socket.io.min.js';
      script.onload = () => {
        const socket = io();
        const respondingSpan = document.getElementById('responding-count');
        const answeredSpan = document.getElementById('answered-count');
        const cloud = document.getElementById('tags-cloud');
        const title = document.querySelector('.title');
        const loader = document.querySelector('.loader');
        const metrics = document.querySelector('.metrics');
        socket.on('bubble_stats', (stats) => {
          if (respondingSpan) respondingSpan.textContent = stats.answering ?? 0;
          if (answeredSpan) answeredSpan.textContent = stats.answered ?? 0;
        });

        function renderCloud(tags) {
          if (!cloud) return;
          cloud.innerHTML = '';
          cloud.classList.add('show');
          // Раскладка по облаку: уникальные теги, случайные позиции, поэтапное появление
          const rectWidth = cloud.clientWidth || 1000;
          const rectHeight = cloud.clientHeight || 560;
          // Не объединяем одинаковые ответы — показываем столько раз, сколько прислали
          const cleaned = tags.map(t => String(t).trim()).filter(Boolean);
          // Подготовка: создаем элементы, меряем, сортируем по размеру (крупные ближе к центру)
          const items = [];
          cleaned.forEach((t, idx) => {
            const el = document.createElement('span');
            el.className = 'tag cloud-enter float';
            el.textContent = t;
            const size = 28 + Math.floor((idx % 8) * 4);
            el.style.fontSize = size + 'px';
            const palette = ['#F94144','#F3722C','#F8961E','#90BE6D','#43AA8B','#577590','#277DA1','#F9C74F','#B5179E','#7209B7','#4895EF','#4D908E'];
            el.style.setProperty('--tag-color', palette[idx % palette.length]);
            const delay = (idx * 180) + Math.floor(Math.random() * 300);
            const rot = (Math.random() * 6 - 3).toFixed(2);
            el.style.setProperty('--delay', `${delay}ms`);
            el.style.setProperty('--rot', `${rot}deg`);
            el.style.setProperty('--floatDelay', `${800 + delay}ms`);
            el.style.visibility = 'hidden';
            el.style.left = '0px';
            el.style.top = '0px';
            cloud.appendChild(el);
            items.push({ el, idx });
          });
          items.forEach(item => {
            item.w = item.el.offsetWidth;
            item.h = item.el.offsetHeight;
          });
          items.sort((a, b) => (b.w * b.h) - (a.w * a.h));
          // Утилиты: раскладка по спирали из центра
          const placed = [];
          // Тщательно защищаем текст: ядро (content box) нельзя перекрывать.
          // Увеличим защиту и введём минимальный зазор между словами.
          const paddingCore = 6;   // защита вокруг букв (px)
          const minGap = 10;       // минимальный зазор между словами (px)
          const intersectsCore = (a, b) => {
            const ac = { left: a.left + paddingCore, top: a.top + paddingCore, right: a.right - paddingCore, bottom: a.bottom - paddingCore };
            const bc = { left: b.left + paddingCore, top: b.top + paddingCore, right: b.right - paddingCore, bottom: b.bottom - paddingCore };
            return !(bc.left >= ac.right || bc.right <= ac.left || bc.top >= ac.bottom || bc.bottom <= ac.top);
          };
          const tooClose = (a, b) => {
            const g = minGap / 2;
            const ao = { left: a.left - g, top: a.top - g, right: a.right + g, bottom: a.bottom + g };
            return !(b.left >= ao.right || b.right <= ao.left || b.top >= ao.bottom || b.bottom <= ao.top);
          };
          const cx = Math.floor(rectWidth / 2);
          const cy = Math.floor(rectHeight / 2);
          const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
          const findSpotSpiral = (w, h) => {
            const maxTurns = 3000; // защита от бесконечной петли
            let theta = 0;
            const step = 0.26; // шаг по углу
            const grow = 7; // шаг радиуса
            for (let i = 0; i < maxTurns; i++) {
              const r = 4 + i * grow / (2 * Math.PI);
              const x0 = Math.round(cx + r * Math.cos(theta) - w / 2);
              const y0 = Math.round(cy + r * Math.sin(theta) - h / 2);
              theta += step;
              const x = clamp(x0, 0, rectWidth - w);
              const y = clamp(y0, 0, rectHeight - h);
              const cand = { left: x, top: y, right: x + w, bottom: y + h };
              // Запрещаем пересечение ядра текста и требуем минимальный зазор между словами
              if (!placed.some(p => intersectsCore(p, cand)) && !placed.some(p => tooClose(p, cand))) return cand;
            }
            // Фоллбэк: сетка
            const maxX = Math.max(0, rectWidth - w);
            const maxY = Math.max(0, rectHeight - h);
            for (let y = 0; y <= maxY; y += 6) {
              for (let x = 0; x <= maxX; x += 6) {
                const cand = { left: x, top: y, right: x + w, bottom: y + h };
                if (!placed.some(p => intersectsCore(p, cand)) && !placed.some(p => tooClose(p, cand))) return cand;
              }
            }
            return { left: 0, top: 0, right: w, bottom: h };
          };
          items.forEach(({ el, w, h }) => {
            const spot = findSpotSpiral(w, h);
            el.style.left = spot.left + 'px';
            el.style.top = spot.top + 'px';
            el.style.visibility = '';
            placed.push({ left: spot.left, top: spot.top, right: spot.left + w, bottom: spot.top + h });
          });
          // Отдельно плавно проявляем само облако, чтобы теги не возникали резко
          requestAnimationFrame(() => {
            cloud.classList.add('visible');
          });
        }

        socket.on('bubble_ready', (payload) => {
          if (title) title.textContent = 'Все ответы получены';
          if (loader) loader.classList.add('fade-out');
          if (metrics) metrics.classList.add('fade-out');
          // Даем анимации скрытия завершиться, затем показываем облако
          const fadeMs = 700;
          setTimeout(() => {
            if (loader) loader.style.display = 'none';
            if (metrics) metrics.style.display = 'none';
            if (cloud) renderCloud(Array.isArray(payload?.tags) ? payload.tags : []);
          }, fadeMs);
        });
      };
      document.head.appendChild(script);
    })();
  </script>
</body>
</html>

